[[search]]
== Searching â€“ the basic tools

This chapter deals with the various APIs available for searching, and explains
the more commonly used search features, such as result paging, sorting,
and snippet highlighting.

=== Search API

* Highlighting
* Retrieving specific fields
* Script fields
* Search types

=== Scrolling
.

=== Scanning
.

=== Count API
.

=== More-like-this API
.

// rescore
// suggest
// facets

// Distributed execution


//    fields          => [$field_1,$field_n],
//    partial_fields  => { my_field => { include => 'foo.bar.*' }},
//    highlight       => { highlight }.
//    ignore_indices  => 'none' | 'missing',
//    indices_boost   => { index_1 => 1.5,... },
//    min_score       => $score,
//    preference      => '_local' | '_primary' | '_primary_first' | $string,
//    routing         => [$routing, ...]
//    script_fields   => { script_fields }
//    search_type     => 'dfs_query_then_fetch'
//                       | 'dfs_query_and_fetch'
//                       | 'query_then_fetch'
//                       | 'query_and_fetch'
//                       | 'count'
//                       | 'scan'
//    scroll          => '5m' | '30s',
//    stats           => ['group_1','group_2'],
//    version         => 0 | 1
//

// msearch
// delete-by-query
//
// refresh
//
//
//     Query
//
//     Rescore
//     Suggest
//     Highlighting
//     Facets
//     Filter
//
//     Search Type
//     Scroll
//     Explain
//     Validate
//
//     Fields
//     Script Fields
//     Preference
//     Version
//     Min Score
//


// Beware of paging too deep. Results are returned in order, usually sorted by
// decreasing relevance `_score`. But these results are generated by different
// shards, and need to be sorted centrally  to ensure that the order
// is correct.
//
// To understand why deep paging is problematic, let's imagine that we
// are searching within a single index, which has 5 primary shards.  When we
// request the first page of results (or results 0 to 9):
//
// 1. The requesting node forwards the search to a primary or replica of each shard
// 2. Each shard runs the query, sorts the results and returns the document ID
//    and `_score` for each result
// 3. The requesting node sorts all 50 results to find the top 10, discarding
//    the other 40 results.
// 4. Then requesting node then retrieves the full document for the top 10
//    results from the relevant shards
// 5. It assembles these into a JSON response, which is returned to the
//    client.
//
// Now imagine that we ask for page 1,000 -- results 10,000 to 10,009. Everything
// works in the same way except that each shard has to send the document
// ID and `_score` for the first 10,009 results.  The requesting node then
// sorts through 50,050 results and discards 50,040 of them.
//
// You can see that, in a distributed system, the cost of sorting results
// grows exponentially the deeper we page.  There is a very good reason
// why web search engines don't return more than 1,000 results at a time.
//
//