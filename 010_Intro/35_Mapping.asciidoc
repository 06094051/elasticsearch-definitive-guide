=== Schema free

When you create a new table in a relational database, the first thing you
do is define the data type of each column. But we've been playing
with Elasticsearch -- indexing, searching, aggregating -- and we haven't defined
one schema yet. Did we hide that step from the intro?

The answer is no: we didn't hide that step. Elasticsearch is _schema free_ --
it doesn't require you to define a schema upfront but will automatically
detect the datatype of each new field in your document and build a schema for
you. Elasticsearch tries hard to get out of your way so that it is easy to
experiment.

Later, we will want more control over this process but, by not requiring
a schema -- by being _schema free_ -- Elasticsearch makes
it easy for us to start experimenting without having to plan ahead.

We can see how our fields from the example have been interpreted by retrieving
the current _mapping_ (aka the schema definition):

[source,js]
--------------------------------------------------
GET /blogs/_mapping
--------------------------------------------------


which looks like this:

[source,js]
--------------------------------------------------
{
  "blogs" : { <1>
    "user" : { <2>
      "properties" : { <3>
        "age" :       { "type" : "long"   },
        "bio" :       { "type" : "string" },
        "email" :     { "type" : "string" },
        "interests" : { "type" : "string" },
        "join_date" : {
            "type" : "date",
            "format" : "yyyy/MM/dd HH:mm:ss||yyyy/MM/dd"
        },
        "name" : {
            "properties" : {
              "first" : { "type" : "string" },
              "last" :  { "type" : "string" }
            }
        }
}}}}
--------------------------------------------------
<1> The `index` name.
<2> The `type` name.
<3> The fields in our type.

We can see that Elasticsearch has done a reasonable job of interpreting our
data types:

* the numeric field `age` has been assigned type `long`
* string fields, including the array field `interests`, are
  assigned type `string`
* the string field `join_date` has correctly been recognised as type `date`
* the inner object `name` has two string fields: `first` and `last`

With the mapping as it is, we are already well positioned to add a search
service to our blogging website.

But search engines are sophisticated.  With the domain specific knowledge
that you have about your own data you can tailor the mapping to your needs
by adding, for example:

 * autocomplete searches to the `title` field
 * language specific analysis to the `title` and `content` fields
 * geolocation information for results-near-you

Instead of relying on the dynamic detection of fields, we can
specify our own custom analyzers and field mapping, taking control over
how the value for each field should be analyzed and indexed.



