=== Search _Lite_

Let's try a search now -- after all, search is one of the reasons you are interested
in Elasticsearch! For simple _ad hoc_ searches, we can use the _query string_ search
method, so called because we pass the

[source,js]
--------------------------------------------------
GET /_search?q=john
--------------------------------------------------

The above query returns our `johnsmith` document as a result. By default,
Elasticsearch searches within all the fields in your document.  If you want to
query a specific field, you can specify it in the query string:

[source,js]
--------------------------------------------------
GET /_search?q=first:john
--------------------------------------------------


Every single field in a document is indexed and searchable by default. It's
the equivalent of a database having an index on every column in
every table, and being able to use multiple indices in a single request!

The search response not only contains the list of which documents match but
also contains the documents themselves. There is no need to have a separate
phase to fetch the matching documents from another datasource.

.Near real-time search
****

While documents can be retrieved immediately after being indexed -- real-time
GET -- they only become ``visible'' to search within 1 second of being indexed
or updated. This is known as  _near real-time search_.

****

=== Full body search

The query string search is useful for simple queries from the command line, but we can use
the _Query DSL_  to express more complex and specific queries in JSON.  The Query DSL is
Elasticsearch's rich and flexible query language and looks like this:

[source,js]
--------------------------------------------------
GET /_search
{
    "query": {
        "bool": {
            "must": { "match": { "name.first": "john" }},
            "should": [
                { "match": { "interests": "whales" }},
                { "match": { "bio": "eco warrior"  }},
                { "range": { "age": { "from": 20   }}}
            ]
        }
    }
}
--------------------------------------------------


The Query DSL gives you complete control over how your query is executed.
Individual clauses are like building blocks which can be put together
in different ways to suit your search needs and performance requirements.
We'll cover how to construct more complicated queries using the Query DSL later.

[[highlighting-intro]]
=== Snippet highlighting

The search API supports other related functionality, such as highlighting
search snippets to show matching terms in the context of the document
content:

[source,js]
--------------------------------------------------
GET /_search
{
    "query": { "match": { "bio": "eco warrior" }},
    "highlight": {
        "fields": {
            "bio": {}
        }
    }
}
--------------------------------------------------


The above query returns snippets like:

[source,html]
--------------------------------------------------
<em>Eco</em>-<em>warrior</em> and defender of the weak
--------------------------------------------------


=== Near real-time analytics

While search returns the ``best-matching'' documents, we can use
_aggregations_ to generate analytics by summarizing all of the documents that
match the query. It's a bit like using `GROUP BY` in SQL.

Aggregations (or `aggs`) can answer questions like:

* What are the most popular tags or categories?
* How many comments have been left per hour, day or month?
* What is the average rating of a hotel?
* How many houses are for sale within 5, 10 or 50km of the user's location?

These questions are often answered with _map-reduce_, which uses offline
batch jobs running in parallel. The results from map-reduce reflect the state
of the data at the time the map-reduce job began, which may be hours, days
or weeks before.

Aggregations in Elasticsearch, however, summarise the data based on current
search results.  This makes analytics derived from aggregations *near
real-time*, instead of hours or days stale. As soon as a new document is visible
to search, its data is also available to aggregations.

A simple example of an aggregation in action is _faceted navigation_: a user
does a search which returns a list of results, plus a list of popular
categories which can then be used to narrow down the results.

The following query returns all objects of type `user` in all indices,
and summarizes the most popular values in the `interests` field:

[source,js]
--------------------------------------------------
GET /_all/user/_search
{
   "query" : {
      "match_all" : {}
   },
   "aggs" : {
      "interests" : {
         "terms" : {
            "field" : "interests"
         }
      }
   }
}
--------------------------------------------------


The `facets` section of the JSON response to the above looks like this:

[source,js]
--------------------------------------------------
"aggregations": {
  "interests": {
     "buckets": [
        { "key": "whales",   "doc_count": 3 },
        { "key": "golf",     "doc_count": 3 },
        { "key": "wine",     "doc_count": 2 },
        { "key": "dolphins", "doc_count": 1 },
        { "key": "cinema",   "doc_count": 1 }
     ]
  }
}
--------------------------------------------------


The two most popular interests are `whales` and `golf`. Our user could narrow
down their search, by limiting the results to just users who are interested in
whales.

The output from facets can often be presented visually, as a pie chart or
a histogram, or geographic results can be overlaid on a map.
