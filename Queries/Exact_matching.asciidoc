[[exact-queries]]
=== Querying exact values

To match against numeric, date, boolean or `not_analyzed`
string fields -- see <<analyzed-vs-not,`analyzed` vs `not_analyzed`>> below
-- we use the `match` query.

It does The Right Thing for each field based on its _mapping_ (or field
definition), which we will discuss in <<mapping>>:

* `not_analyzed` (enum) string fields

[source,js]
--------------------------------------------------
 { "match" : { "status" : "active" }}
--------------------------------------------------


* numbers

[source,js]
--------------------------------------------------
 { "match" : { "count" : 5 }}
--------------------------------------------------


* dates

[source,js]
--------------------------------------------------
 { "match" : { "created" : "2013/05/01" }}
--------------------------------------------------


* booleans

[source,js]
--------------------------------------------------
 { "match" : { "featured" : true }}
--------------------------------------------------



[[analyzed-vs-not]]
.`analyzed` vs `not_analyzed` string fields
****
String fields can contain either:

_Full text_::

like the body of an email, which should be _analyzed_ in order to be searchable.
The full text string `"The Quick Brown Fox!"` may, depending on the analyzer,
be indexed as the tokens: `["quick", "brown", "fox"]`.

_Exact values_::

like enums, post codes, product numbers, or tags, which are *not* analyzed
but are indexed exactly as they are, so the string `"Foxes Rule!"` would be
indexed as the single token `"Foxes Rule!"`.

By default, Elasticsearch assumes that all string fields contain
full text. They are defined (or ``mapped'') as:

[source,js]
--------------------------------------------------
 { "type": "string", "index": "analyzed" }
--------------------------------------------------


String fields which contain exact values have to be manually defined as:

[source,js]
--------------------------------------------------
 { "type": "string", "index": "not_analyzed" }
--------------------------------------------------


We will explain how to setup `not_analyzed` fields in <<mapping>>, but for
now, it is important to know the distinction between the two.
****

Normally, we would use filters for exact value matches as these clauses seldom
contribute to the relevance `_score`.  Instead, they typically function as
`yes|no` questions: ``is the `status` field `active`?'' or
``is the `published` date `2012/01/01`?''.

However, sometimes we *do* want them to contribute to relevance:

A user on a job website searches for the tags `html6`, `css3` and `jquery`.
We want at least one of these tags to match, but the more tags that match,
the better.

We could write this by combining three `match` clauses with a
<<bool-query,`bool` query>>:

[source,js]
--------------------------------------------------
 {
     "bool": {
         "should": [
             { "match": { "tag": "html6"  },
             { "match": { "tag": "css3"   },
             { "match": { "tag": "jquery" }
         ]
     }
 }
--------------------------------------------------


Also, because `html6` is such a rare tag, any job tagged with `html6` will
show up as being particularly relevant.

[NOTE]
====
Later, we will discuss the
<<custom-filters-score-query,`custom_filters_score` query>> which provides a
way to use filters to influence the relevance `_score` more efficiently.
====

