[[fuzzy_matching]]
=== Fuzzy matching

Fuzzy matching is a useful techinque for matching words that have been
misspelled or have an alternate spelling. Compare:

* `bieber`    vs `beiber`     vs `beaber`
* `esophagus` vs `oesophagus` vs `Å“sophagus`

==== How do we measure fuzziness?

There are many ways to match strings approximately. We could use a
phonetic algorithm like http://en.wikipedia.org/wiki/Soundex[Soundex] or
http://en.wikipedia.org/wiki/Metaphone:[Metaphone] to find words that sound
similar. Alternatively, we could break the search terms into all possible
substrings and compare them to all of the substrings of all terms in our index.

The way that Lucene and Elasticsearch have chosen to measure fuzziness
is with the
http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance[Damerau-Levenshtein edit distance],
which counts the number of changes that have to be made to one string in order
to convert it into the target string.  A change could be the insertion, deletion
or substitution of a single character, or the transposition of two adjacent
characters.

To use our example above, `beaber` -> `bieber` has an edit distance of 2:

1. ``be**a**ber'' -> ``be**i**ber'' (replace `a` with `i`)
2. ``b**ei**ber'' -> ``b**ie**ber'' (transpose `e` and `i`)

Damerau observed that 80% of human misspellings have an edit distance of 1. In
other words, 80% of misspellings could be corrected with a single edit
to the original string.

****
The substring comparison approach, although it appears to be very
computationally heavy, actually works very well as long as you have precomputed
all the substrings in your index.  We will examine this further in [TODO] ADD
LINK TO NGRAMS EXAMPLE.
****

==== Generating a fuzzy query

Unfortunately, the use of an inverted index -- the structure that makes
Elasticsearch as fast as it is -- requires us to know exactly which terms to
look for before searching.

That means that, in order to be able to perform fuzzy matches, we need to know
ahead of time which of the terms in our index might match a fuzzy version of
our search terms. Once we have the list, we can search for all (or many)
of them and return the best matching results.

The naive way to build this term list is to calculate the edit distance between
the search term and every term in the index, discarding those whose edit
distance is too large. This may be naive, but this was the way that
the fuzzy query was implemented in Lucene up until version 4.  As a
consequence, the fuzzy query could perform very badly.

==== Enter the automaton

Lucene version 4 uses a different approach -- it processes the search terms
and calculates all possible variations that have a maximum edit distance
of 2, and stores them in a very efficient structure called a
_Deterministic Finite Automaton_ (DFA). This DFA makes it possible to check
which of these terms actually exist in the term dictionary in a much more
efficient way. The result: fuzzy queries are now 100 times faster than they
used to be.

Once Elasticsearch has gatherered a list of all possible matching terms that
exist in the index, it wraps the ``most important'' terms in a
<<bool_query,boolean query>> and searches for all of them. Terms with a lower
edit distance are considered to be more relevant.

==== No such thing as a free lunch

While fuzzy queries now perform very much better than they did, they still have
a cost: the DFA data structure is very large and consumes a lot of memory.
Generating it requires the creation of over 25,000 objects, all of which
then need to be garbage collected.

Before using fuzzy queries, you should:

* make sure that you have ample free memory
* restrict your use of fuzziness to a single field and a few search terms
* use the `prefix_length` parameter to reduce the number of edits that
  have to be calculated
* consider using the `max_expansions` parameter to reduce the number of
  generated fuzzy terms which will be searched on -- the default is 50
* consider using an edit distance of 1 instead of the default 2, as this
  creates a much smaller DFA
* consider using the approach outlined in the [TODO] ADD LINK TO NGRAM
  EXAMPLE instead of using fuzzy queries















