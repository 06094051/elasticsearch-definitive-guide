
[[match-phrase-query]]
=== Phrase matching

Instead of just matching the words in the query string, we can also
match a _phrase_, that is: all the words, in the *same order and position*.
The phrase `"quick fox"` would not match a document containing
`"quick brown fox"`.

[source,js]
--------------------------------------------------
 {
     "match_phrase" : {
         "title" : "quick fox"
     }
 }
--------------------------------------------------


****
The `match_phrase` query is a sub-type of the `match` query and can also be
written as:

[source,js]
--------------------------------------------------
 {
     "match" : {
         "title" : {
             "type":  "phrase",
             "query": "quick fox"
         }
     }
 }
--------------------------------------------------

****


==== `slop`

The `slop` parameter allows us to relax the strict _same order_ constraint,
and causes the `match_phrase` query to behave more like a _proximity_ query,
i.e. the nearer the words are to each other, the more relevant.

[source,js]
--------------------------------------------------
 {
     "match_phrase" : {
         "title: {
             "query" : "quick fox",
             "slop"  : 5
         }
     }
 }
--------------------------------------------------


_Slop_ behaves like a Levenshtein edit distance without deletions, but based
on word positions instead of single character changes.  To make the phrase
`"quick fox"` match `"quick brown fox"` requires a `slop` of `1`:

1.  `[ 1:quick 2:fox ]` -> `[ 1:quick 2:___ 3:fox ]`

A `slop` of `3` would allow `"fox quick"` to match, albeit with a
lower relevance `_score` than `"quick fox"`.

1. `[ 1:fox 2:quick ]` -> `[ 1:fox 1:quick ]`
2. `[ 1:fox 1:quick ]` -> `[ 1:quick 2:fox ]`
3. `[ 1:quick 2:fox ]` -> `[ 1:quick 2:___ 3:fox ]`

[TIP]
====
Use a `match_phrase` query with a high `slop` value to find all specified words,
in any order, but giving preference to those documents where the word order
is most similar to the order in the query string.
====


[[match-phrase-prefix-query]]
=== Find-as-you-type

The `match_phrase_prefix` query is a specialization of the
<<match-phrase-query,`match_phrase` query>> which is particularly useful
for _find-as-you-type_ searches.  It works in the same way as the
`match_phrase` query, but adds a wildcard (`*`) to the final word.

The example below would match `"quick brown fox"` and
`"quick brown furry animals"`:

[source,js]
--------------------------------------------------
 {
     "match_phrase_prefix" : {
         "title: {
             "query" : "quick brown f"
         }
     }
 }
--------------------------------------------------


The `match_phrase_prefix` query also accepts the `slop`
parameter, to allow the words to be near to each other, without necessarily
being in the same order. However, only the last word in the query string
is used for the prefix query.

****
Like the `match_phrase` query, the `match_phrase_prefix` query is a variant
of the <<match-query,`match` query>> and can be written as:

[source,js]
--------------------------------------------------
 {
     "match" : {
         "title: {
             "type"  : "phrase_prefix",
             "query" : "quick brown f"
         }
     }
 }
--------------------------------------------------

****


==== `max_expansions`

The prefix part of the query can generate many sub-queries. For performance
reasons, you can limit the number of sub-queries with `max_expansions`.

[source,js]
--------------------------------------------------
 {
     "match_phrase_prefix" : {
         "title: {
             "query"          : "quick brown f",
             "max_expansions" : 10
         }
     }
 }
--------------------------------------------------


In the above example, if there are more than 10 terms that begin with `f` in
our index, it will search for just the first 10 that occur in alphabetical
order. If no `max_expansions` is set, and there are more than 1,024
possible matching terms, an error will be thrown.  Always set
`max_expansions`.

