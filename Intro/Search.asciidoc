=== Search _Lite_

Let's try a search now -- after all, search is one of the reasons you are interested
in Elasticsearch! For simple _ad hoc_ searches, we can use the _query string_ search
method:

[source,js]
--------------------------------------------------
GET /_search?pretty&q=john
--------------------------------------------------


The above query returns our `johnsmith` document as a result. By default, Elasticsearch
is searching all the fields in your document.  If you want to search a specific field,
you can specify it as a URI parameter:

[source,js]
--------------------------------------------------
GET /_search?pretty&q=first:john
--------------------------------------------------


Every single field in a document is indexed and searchable by default. It's
the equivalent a database having an index on every column in
every table, and be able to use multiple indices in a single request!

The search response contains not only the list of which documents match, but
also returns the document itself. There is no need to have a separate phase to
fetch the matching documents from another datasource.

.Near real-time search
****
While documents can be retrieved immediately after being indexed (real-time GET) they only become ``visible'' to search within 1 second of
being indexed or updated. This is known as  _near real-time search_.
****

=== Full body search

The query string search is useful for simple queries from the command line, but we can use
the _Query DSL_  to express more complex and specific queries in JSON.  The Query DSL is
Elasticsearch's rich and flexible query language and looks like this:

[source,js]
--------------------------------------------------
GET /_search?pretty
{
    "query": {
        "bool": {
            "must": { "match": { "name.first": "john" }},
            "should": [
                { "match": { "interests": "whales" }},
                { "match": { "bio": "eco warrior"  }},
                { "range": { "age": { "from": 20   }}}
            ]
        }
    }
}
--------------------------------------------------


The Query DSL gives you complete control over how your query is executed.
Individual clauses are like building blocks which can be put together
in different ways to suit your search needs and performance requirements.
We'll cover how to construct more complicated queries using the Query DSL later.

=== Snippet highlighting

The search API supports other related functionality, such as highlighting
search snippets to show matching terms in the context of the document
content:

[source,js]
--------------------------------------------------
GET /_search?pretty
{
    "query": { "match": { "bio": "eco warrior" }},
    "highlight": {
        "fields": {
            "bio": {}
        }
    }
}
--------------------------------------------------


The above query returns snippets like:

[source,js]
--------------------------------------------------
<em>Eco</em>-<em>warrior</em> and defender of the weak
--------------------------------------------------


=== Near real-time analytics

While search returns the ``best-matching'' documents, we can use _facets_
to generate analytics by summarizing all the documents that match the query.
It's a bit like using `GROUP BY` in SQL.

Facets can answer questions like:

* What are the most popular tags or categories?
* How many comments have been left per hour, day or month?
* What is the average rating of a hotel?
* How many houses are for sale within 5, 10 or 50km of the user's location?

These questions are often answered with _map-reduce_, which uses offline
batch jobs running in parallel. The results from map-reduce reflect the state
of the data at the time the map-reduce job began, which may be hours, days
or weeks before.

Facets in Elasticsearch, however, summarise the data based on current search
results.  This makes analytics derived from Facets near real-time, instead of hours
or days stale. As soon as a new document is visible to search, its data is also available
to facets.

A simple example of facets in action is _faceted navigation_: a user
does a search which returns a list of results, plus a list of popular
categories which can then be used to narrow down the results.

The following query returns all objects of type `user` in all indices,
and summarizes the most popular values in the `interests` field:

[source,js]
--------------------------------------------------
GET /_all/user/_search?pretty
{
   "query" : {
      "match_all" : {}
   },
   "facets" : {
      "interests" : {
         "terms" : {
            "field" : "interests"
         }
      }
   }
}
--------------------------------------------------


The `facets` section of the JSON response to the above looks like this:

[source,js]
--------------------------------------------------
"facets" : {
   "interests" : {
      "_type" : "terms",
      "total" : 7
      "terms" : [
         { "count" : 2, "term" : "whales"   },
         { "count" : 2, "term" : "golf"     },
         { "count" : 1, "term" : "wine"     },
         { "count" : 1, "term" : "dolphins" },
         { "count" : 1, "term" : "cinema"   }
      ],
      "other" : 0,
      "missing" : 0,
   }
},
--------------------------------------------------


The two most popular interests are `whales` and `golf`. Our user could choose
to repeat their search, but limiting the results to just users who are
interested in whales.

The output from facets can often be presented visually, as a pie chart or
a histogram, or geographic results can be overlaid on a map.
