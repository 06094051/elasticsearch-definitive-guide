
==== Caching
Earlier, we mentioned that filters are cached for performance reasons.  This is
true for _nearly_ all filters, with a few exceptions.  The `bool` filter is one
of those exceptions.

By default, the `bool` filter *is not* cached.  In practice, most compound
filters are dynamically generated by your application.  The constituents of the
filter changes from query to query, so it doesn't make much sense to cache the
entire `bool`.  Rather, we'll just leverage the cached filters that make up
the `bool`, which is nearly always more efficient

By default, the `bool` filter _is not_ cached, unlike the majority of other 
filters. In practice, most compound filters combine a number of dynamically 
generated conditions.  Caching the "total set" of filters just wastes memory and
I/O, since any particular combination of filters is unlikely to surface again.

Sometimes, however, it makes sense to cache the compound filter.  If you find
yourself always specifying the same combination of filters inside a `bool`,
consider caching the entire compound set by setting `_cache` to true.  This will
cause the entire `bool` to be cached as a single bitset which in some arrangements
may be more efficient.








==== Execution Mode: Plain
The `execution_mode` attribute controls how the `terms` filter builds its bitsets
internally.

The default execution mode is `plain`, which creates a composite bitset.
Using our example above, the filter will generate two bitsets (where a 1 represents
a document that has the term):

1. *Construct a bitset for "Twelfth Night"*
+
Only the first document has the term, so the bitset is: `[1,0,0,0]`

2. *Construct a bitset for "twelfth night"*
+
Only the third document has the term, so the bitset is: `[0,0,1,0]`

3. *Merge the bitsets*
+
Resulting bitset is the union of the first two, using a bitwise OR: `[1,0,1,0]`

The final bitset represents all the documents that have _any_ of the
specified terms, which means the `terms` filter is an OR operation (if that
doesn't quite make sense, sit tight: we'll talk about it more in 
"<<_contains_but_does_not_equal>>").

This final, composite bitset is cached instead of the individual bitsets.
This is often more efficient use of space, since the final filter may be composed
of many small bitsets which are largely zero-values.  Packing them together
into a single filter tends to save space and speed.

So to answer the question _"does Elasticsearch build a `bool` filter internally"_,
the answer is no, by default it does not.  It uses the `plain` execution mode
which optimizes the bitset creation process.

==== Execution Mode: Bool
There is, however, another mode that is called `bool`.  As you might guess, this
tells Elasticsearch to construct a `bool` filter internally instead of a 
composite bitset.

With `execution_mode: bool`, our original query is internally transformed into
this query:

[source,js]
--------------------------------------------------
{
    "query" : {
        "filtered" : {
            "filter" : {
                "bool" : {
                    "should" : [
                        {"term" : {"title" : "Twelfth Night"}},
                        {"term" : {"title" : "twelfth night"}},
                    ]
                }
            }
        }
    }
}
--------------------------------------------------

The final result is the same: documents one and three are returned.  So why
would you choose `bool` over `plain`?  The difference is how the bitsets are
cached.

In `plain`, the final bitset is a union of all term's bitsets.  We only cached
the final, composite bitset.  With `bool`, individual `term` filters are cached 
independently (just like a normal `bool` filter).  The final bitset is not
cached.

Generally speaking, the default `plain` mode is a better choice.  But `bool` can
be useful in situations where you have a small cardinality of filters that
may be combined in large number of permutations.

For example, if you have 20 different colors used in sets of nine, you may have
to cache up to 167,960 different combinations when using `plain`.  If you don't
have the memory to hold all 167,960 bitsets in memory, you'll start evicting
filters.  At the extreme end, if none of the filters are reused you may end up
caching and evicting thousands of worthless filters.

By contrast, if you select `bool`, there are only 20 individual colors that need
to be cached.  All the permutations are simply combined in the `bool` filter
and you won't churn your cache constantly with evictions.

It is hard to give generic, blanket advice regarding which `execution_mode` you
should choose.  The default `plain` works very well, but sometimes you may need
to manually intervene.  Carefully consider the types of filters you are using,
their cardinality and how often they will get reused before making your choice.

If in doubt, stick to the default `plain` mode...defaults in Elasticsearch are
chosen because they work for 95% of people!









At this point, you've seen repeated recommendations to use filters whenever 
possible, due to their performance benefit. But you may be wondering _why_ 
filters are more performant.

We are going to take a quick detour and talk about how filters work internally.
A good understanding of the internals will let you optimize your queries for
maximum performance.

We've already discussed bitsets some in "<<_term_filter>>", but we are going to 
talk about them in a bit more detail. As you already know, bitsets are simply 
arrays of bits (1's and 0's).  They are  very compact which makes them excellent 
for in-memory operations.  Elasticsearch can efficiently store many different
filters in memory.

The first time a filter is executed, it iterates over each document and 
evaluates the filter: _"Does this document match?"_

If the answer is Yes, a `1` is placed in the bitset for that document; otherwise,
a `0` is recorded.  This is repeated for all the documents in your index.

When the filter is finished, you will have an array of bits representing the
matching status of each document.  This bitset is then used to mask the index,
such that only documents with a `1` bit (e.g. matching the filter) are evaluated
with the query.

This alone has big performance benefits.  Relevancy and scoring requires
computation.  While a single score calculation is very fast, your query
may match _billions_ of documents, and scoring a billion documents can take 
some time.  If you are aiming for sub-second response times, this can pose a
real problem.

Filters allow you to skip the scoring step for documents that wouldn't have 
been a hit anyway, since they don't match the filter criterion.

The real performance advantage comes the next time the filter is 
used.  Instead of iterating over each document (which usually requires disk I/O 
and CPU to evaluate the filter), Elasticsearch merely looks at the array of bits
and finds all positions with a `1`.

This provides huge performance benefits, since retrieving the bitset from memory
and masking the index is orders of magnitude faster than evaluating the filter
against each document.

Filters provide two layers of performance.  First, it avoids scoring calculations
on unnecessary documents.  Second, they are cached so that future filtering
can skip the filter evaluation step.

.Independent filter caching
****
Filters are cached independently from the query, which makes them reusable
in many different contexts.  If two different queries use the same filter,
the same filter bitset will be reused.

This ties in nicely with the composability of the query DSL.  It is easy to
move filters around, or reuse the same filter in multiple places within the
same query.  This isn't just convenient to the developer -- it has direct
performance benefits because the bitsets are reused internally.
****

Evaluating filters by looking at the bits is already a powerful technique, but
another benefit lies in multi-filter operations.  Since the bitset is just 
an array of bits, we can perform bitwise operations.  

For example, finding the union of two terms is just a bitwise OR on the two 
filter bitsets. Similarly, the intersection of two terms is just a bitwise AND.

These bitwise operations are so basic -- so fundamental to computing -- that your 
CPU has dedicated hardware to perform bitwise calculations.  It is hard to 
overstate how fast these operations are. They are literally several orders of 
magnitude faster than that retrieving the documents from disk
(or even memory!) and evaluating the filter.


