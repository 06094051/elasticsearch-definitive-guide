
Filtering on ranges is a very common structured search. Elasticsearch allows
filtering on both numeric and string-based ranges.  There are a few options
depending on your use-case.

==== Range Filter

The standard range component is the Range Filter.  This automatically detects
the type you are working with (numeric or string) and applies the correct
Lucene Range filter.

.Working with strings?
****
If you are filtering string ranges, make sure the analyzer is configured
appropriately.  Often, it is a good idea to set a field `not_analyzed`, or at
least lowercased, so that fields are ordered appropriately.

If a field is analyzed into multiple tokens, you may get strange results matching
your range filter and not understand why.
****

==== Numeric_Range Filter

Elasticsearch has a special filter that is designed explicitly for numbers.
The filter comes with some minor performance advantages at the expense of memory.

Instead of constructing a bitset, the numeric_range filter loads all values into
memory (in the Field Data) and then performs the necessary calculations.

This means that the Numeric_Range filter can potentially use a lot of memory.

The regular Range filter is already pretty fast, so why bother using numeric_range?
This filter can be useful if you already have the values loaded into
Field Data through some other operation (faceting, sorting, etc).  Numeric_Range
will simply reuse those values.

In practice, you'll usually be using the Range Filter.  But if you are working
with numbers, it may be a good idea to try out Numeric_Range to see if it improves
memory usage or performance.

.Are you using the Range Query?
****
If you are using the Range Query...chances are good you should switch it to a
Range filter (or Numeric_Range).

Queries score a document based on its relevance. How does relevance apply to
ranges?  It doesn't!  A value is either inside the range, or it is not.  You can't
be _more_ inside a range.

Realistically, there is no good reason to ever use the Range Query...use Range
or Numeric_Range filter instead.
****