
Now that we have seen the `term` filter and how to combine multiple filters 
with `bool`, the `terms` filter will be easy to understand.  At a high level,
the `terms` filter is simply the plural version of the singular `term` filter.

It accepts an array of terms and returns documents which contain one or more
terms.  If we use the same dataset from earlier in the chapter:

[source,js]
--------------------------------------------------
POST /my_index/my_type/_bulk
{ "index": { "_id": 1 }}
{ "title" : "Twelfth Night" }
{ "index": { "_id": 2 }}
{ "title" : "TWELFTH NIGHT" }
{ "index": { "_id": 3 }}
{ "title" : "twelfth night" }
{ "index": { "_id": 4 }}
{ "title" : "twelfth" }
--------------------------------------------------

And then query it with the following `terms` filter:

[source,js]
--------------------------------------------------
{
    "query" : {
        "filtered" : {
            "filter" : {
                "terms" : {
                    "title" : ["Twelfth Night", "twelfth night"]
                }
            }
        }
    }
}
--------------------------------------------------

The query will return first and third document.  It's as if we had built a `bool`
with two `term` filters inside the Should clause.  Is that what the `terms` filter
does internally?

To answer that question, we need to look at the `execution_mode` attribute.

==== Execution Mode: Plain
The `execution_mode` attribute controls how the `terms` filter builds its bitsets
internally.

The default execution mode is `plain`, which creates a composite bitset.  
Using our example above, the filter will generate two bitsets (where a 1 represents
a document that has the term):

1. *Construct a bitset for "Twelfth Night"*
+
Only the first document has the term, so the bitset is: `[1,0,0,0]`

1. *Construct a bitset for "twelfth night"*
+
Only the third document has the term, so the bitset is: `[0,0,1,0]`

1. *Merge the bitsets*
+
Resulting bitset is the union of the first two, using a bitwise OR: `[1,0,1,0]` 

The final bitset represents all the documents that have _any_ of the
specified terms, which means the `terms` filter is an OR operation (if that
doesn't make sense, sit tight: we'll talk about it more in 
<<_contains_but_does_not_equal>>).

This final, composite bitset is cached instead of the individual bitsets.
This is often more efficient use of space, since the final filter may be composed
of many small bitsets which are largely zero-values.  Packing them together
into a single filter tends to save space and speed.

==== Execution Mode: Bool
The other useful execution mode is `bool`, which tells Elasticsearch to construct
a `bool` filter internally instead of a composite bitset.

With `execution_mode: bool`, our original query is internally transformed into 
this query:

[source,js]
--------------------------------------------------
{
    "query" : {
        "filtered_query" : {
            "query" : { "match_all" : {} },
            "filter" : {
                "bool" : {
                    "should" : [
                        {"term" : {"title" : "Twelfth Night"}},
                        {"term" : {"title" : "twelfth night"}},
                    ]
                }
            }
        }
    }
}
--------------------------------------------------

The final result is the same: documents one and three are returned.  So why 
would you choose `bool` over `plain`?  The difference is how the bitsets are 
cached.

In `plain`, the final bitset is a union of all term's bitsets.  We only cached
the final, composite bitset.  With `bool`, individual `term` filters are cached 
individually (just like a normal `bool` filter) while the final bitset is not
cached.

Generally speaking, the default `plain` mode is a better choice.  But `bool` can 
be useful in situations where you have a small cardinality of filters that 
may be combined in large number of permutations.  

For example, if you have 20 different colors used in sets of nine, you may have 
to cache up to 167,960 different combinations when using `plain`.  If you don't 
have the memory to hold all 167,960 bitsets in memory, you'll start evicting 
filters.  At the extreme end, if none of the filters are reused you may end up 
caching and evicting thousands of worthless filters.

By contrast, if you select `bool`, there are only 20 individual colors that need
to be cached.  All the permutations are simply combined in the `bool` filter
and you won't churn your cache constantly with evictions.

It is hard to give generic, blanket advice regarding which `execution_mode` you
should choose.  The default `plain` works very well, but sometimes you may need
to manually intervene.  Carefully consider the types of filters you are using,
their cardinality and how often they will get reused before making your choice.

