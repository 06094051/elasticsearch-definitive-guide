When working with exact values, you will be working with filters. Filters are important because they are very, very fast.  Filters do not
calculate relevance (avoiding the entire scoring phase) and are easily cached.
We'll talk about the performance benefits of filters later in 
<<_bitsets_the_secret_sauce>>, but for now, just keep in mind that you should
use filters as often as you can.

==== Term Filter with Numbers

We are going to explore the `term` filter first because you will find yourself
using it often.  This filter is capable of handling numbers numbers and dates
just as well as text.

Let's look at an example using numbers first by indexing some products.  These
documents have a `price` and a `productID`:

[source,js]
--------------------------------------------------
POST /my_store/products/_bulk
{ "index": { "_id": 1 }}
{ "price" : 10, "productID" : "XHDK-A-1293-#fJ3" }
{ "index": { "_id": 2 }}
{ "price" : 20, "productID" : "KDKE-B-9947-#kL5" }
{ "index": { "_id": 3 }}
{ "price" : 30, "productID" : "JODL-X-1937-#pV7" }
{ "index": { "_id": 4 }}
{ "price" : 30, "productID" : "QQPX-R-3956-#aD8" }
--------------------------------------------------

Our goal is to find all products with a certain price.  You may be familiar
with SQL if you are coming from a relational database background.  If we
expressed this query as an SQL query, it would look like this:

[source,sql]
--------------------------------------------------
SELECT document
FROM products
WHERE price = 20
--------------------------------------------------
In Elasticsearch DSL, the syntax is a little different.  We will use a `term` 
filter instead:

[source,js]
--------------------------------------------------
GET /my_store/products/_search
{
    "query" : { <1>
        "filtered" : { <1>
            "query" : {}, <2>
            "filter" : {
                "term" : { <3>
                    "price" : 20 
                }
            }
        }
    }
}
--------------------------------------------------

<1> The top level `query` clause wants a query, but since we want to use 
filters, we must wrap our filter in a `filtered_query` (introduced 
in <<_literal_filtered_literal_query>>). A `filtered_query` is a query that 
accepts a `query` and a `filter`. It executes the `filter` clause first and only
evaluates the `query` on documents that matched the filter
<2> If the `query` clause is empty (or omitted) then the search results are 
simply the set of documents that matched the filter.
<3> The `term` filter is being used to find all documents where `price = 20`

The search results from this query are exactly what you would expect: only 
document `2` is returned as a hit:

[source,json]
--------------------------------------------------
"hits" : [ 
    {
        "_index" : "my_store",
        "_type" : "products",
        "_id" : "2",
        "_score" : 1.0, <1>
        "_source" : { 
          "price" : 20,
          "productID" : "KDKE-B-9947-#kL5"
        }
    } 
]
--------------------------------------------------
<1> Filters do not perform scoring or relevance, so all documents that match
a filter receive a score of one.

==== Term Filter with Text
As mentioned at the top of this section, the `term` filter can match strings
just as easily as numbers.  Instead of price, let's try to find products that
have a certain UPC identification code.

Structured search with strings require a little planning first, however.  A
number is easy because it is simply a number...there is no analysis process.

But strings are analyzed by default (see <<analysis-intro>>), and this will
ruin our attempts at exact matching.  Imagine we have the UPC `XHDK-A-1293-#fJ3`,
the default analyzer will index this as three distinct tokens:

- `xhdk`
- `1293`
- `fj3`

There are a couple of important points here.  Obviously, we have three distinct
tokens instead of a single token representing the UPC.  But also notice how
all characters are lowercased, that we lost hyphens and the hash (#) sign, and
the `A` was removed entirely because the analyzer thought it was a stop-word.

Obviously, this is not what we want to happen when dealing with identification
codes, or any kind of precise enumeration.

To prevent this from happening, we need to tell Elasticsearch to `not_analyze` 
the field when indexing.  We saw this originally in 
<<_customizing_field_mappings>>.  To do this, we need to first delete our old
index (because it has the incorrect mapping) and create a new one with the 
correct mappings:

[source,js]
--------------------------------------------------
DELETE /my_store <1>

PUT /my_store <2>
{
    "mappings" : {
        "products" : {
            "properties" : {
                "productID" : {
                    "type" : "string",
                    "index" : "not_analyzed" <3>
                }
            }
        }
    }
    
}
--------------------------------------------------
<1> Deleting the index first is required, since we cannot change mappings that
already exist.
<2> With the index deleted, we can recreate it with out custom mapping
<3> Here we explicitly say that we don't want `productID` to be analyzed

Now that we have told Elasticsearch to `not_analyze` the ID field, we can 
go ahead and index some documents.

[source,js]
--------------------------------------------------
POST /my_store/products/_bulk
{ "index": { "_id": 1 }}
{ "price" : 10, "productID" : "XHDK-A-1293-#fJ3" }
{ "index": { "_id": 2 }}
{ "price" : 20, "productID" : "KDKE-B-9947-#kL5" }
{ "index": { "_id": 3 }}
{ "price" : 30, "productID" : "JODL-X-1937-#pV7" }
{ "index": { "_id": 4 }}
{ "price" : 30, "productID" : "QQPX-R-3956-#aD8" }
--------------------------------------------------

Now, getting back to our original question, let's find all products that have
the ID code `XHDK-A-1293-#fJ3`.  A representative SQL query would look like 
this:

[source,sql]
--------------------------------------------------
SELECT document
FROM products
WHERE productID = "XHDK-A-1293-#fJ3"
--------------------------------------------------
And we once again use the `term` filter to find the exact match we are looking 
for:

[source,js]
--------------------------------------------------
GET /my_store/products/_search
{
    "query" : {
        "filtered" : {
            "filter" : {
                "term" : { 
                    "productID" : "XHDK-A-1293-#fJ3"
                }
            }
        }
    }
}
--------------------------------------------------

Since the `productID` field is not analyzed, and the `term` filter performs no
analysis, the query finds the exact match and returns document `1` as a hit. 


==== Internal Filter Operation

Internally, Elasticsearch is performing several operations when executing a 
filter:

1. *Find Matching Docs*
+
The `term` filter looks up the term `"XHDK-A-1293-#fJ3"` in the inverted index 
and retrieves the list of documents that contain that term.  In this case, 
only document `1` has the term we are looking for

2. *Build a Bitset*
+
The filter then builds a bitset (array of 1's and 0's) which describes which
documents contain the term.  In our example, the bitset would be: 
`[1,0,0,0]`

3. *Cache the Bitset*
+
Lastly, the bitset is stored in memory, since we can use this in the future and
skip step 1. and 2.  This adds a lot of performance and makes filters very
fast.

When executing a query that has filters, it will either evaluate and cache the
bitset (as described above), or simply retrieve the bitset from memory.  Once
all the bitsets are gathered, a simple bitwise AND will yield the final set of
documents that match the filter.




