When working with exact values, you will be mainly working with filters - 
the `term` filter in particular.  This filter performs no analysis steps - it 
simply searches for the exact query text that you provide.  

==== Term Filter

Let's walk through a simple example of how the `term` filter works, both 
from an end-user perspective and internally.  Imagine we have indexed a few 
documents (and the title field is `not_analyzed`):

[source,js]
--------------------------------------------------
POST /my_index/my_type/_bulk
{ "index": { "_id": 1 }}
{ "title" : "Twelfth Night" }
{ "index": { "_id": 2 }}
{ "title" : "TWELFTH NIGHT" }
{ "index": { "_id": 3 }}
{ "title" : "twelfth night" }
{ "index": { "_id": 4 }}
{ "title" : "twelfth" }
--------------------------------------------------


Now we want to find the exact value "Twelfth Night".  We only want the
document that has that term _exactly_.  To do this, we use a `term` filter 
inside of a `filtered` query:

[source,js]
--------------------------------------------------
GET /my_index/my_type/_search
{
    "query" : {
        "filtered" : {
            "filter" : {
                "term" : {
                    "title" : "Twelfth Night"
                }
            }
        }
    }
}
--------------------------------------------------

Internally, Elasticsearch is performing several operations when executing a 
filter:

1. *Find Matching Docs*
+
The `term` filter looks up the term `"Twelfth Night"` in the inverted index and
retrieves the list of documents that contain that term.  In this case, document 
`1` has the term we are looking for

2. *Build a Bitset*
+
The filter then builds a bitset (array of 1's and 0's) which describes which
documents contain the term.  In our example, the bitset would be: `[1,0,0,0]`

3. *Mask the Index*
+
With the bitset in hand, the documents in the index are "masked". Only
documents containing the term will be evaluated by the query. Since our example
has no query, all matching documents are returned.

4. *Cache the Bitset*
+
Lastly, the bitset is stored in memory, since we can use this in the future and
skip step 1. and 2.  This adds a lot of performance and makes filters very
fast.

The results are exactly as you would expect: only the first document is returned
as a hit. None of the other documents are returned, since none of them have the
term *exactly* as we specified in the filter.

[source,json]
--------------------------------------------------
"hits" : [ 
    {
        "_index" : "my_index",
        "_type" : "my_type",
        "_id" : "1",
        "_score" : 1.0, <1>
        "_source" : { 
          "title" : "Twelfth Night" 
        }
    } 
]
--------------------------------------------------
<1> Notice how the score of the document is one.  Filters don't perform any 
scoring, so all documents that match a filter automatically get a score of one
unless modified by a query.
