When working with exact values, you will be working with filters.  And the most 
common filter that you will be using is the `term` filter.  This filter performs
no analysis steps - it simply searches for the exact query text that you provide.  

==== Term Filter

Let's walk through a simple example of how the `term` filter works, both 
from an end-user perspective and internally.  Imagine we have indexed a few 
documents (and the title field is `not_analyzed`):

[source,js]
--------------------------------------------------
POST /my_index/my_type/_bulk
{ "index": { "_id": 1 }}
{ "title" : "Twelfth Night" }
{ "index": { "_id": 2 }}
{ "title" : "TWELFTH NIGHT" }
{ "index": { "_id": 3 }}
{ "title" : "twelfth night" }
{ "index": { "_id": 4 }}
{ "title" : "twelfth" }
--------------------------------------------------


And now we want to find an exact value: "Twelfth Night".  We only want the
document that has that term _exactly_.  To do this, we use a `term` filter 
inside of a `filtered` query:

[source,js]
--------------------------------------------------
GET /my_index/my_type/_search
{
    "query" : {
        "filtered" : {
            "filter" : {
                "term" : {
                    "title" : "Twelfth Night"
                }
            }
        }
    }
}
--------------------------------------------------

Let's look at how this works internally:

1. *Find Matching Docs*
+
The `term` filter looks up the term `"Twelfth Night"` in the inverted index and
retrieves the list of documents that contain that term.  In this case, it is
only document `1`

2. *Build a Bitset*
+
The filter then builds a bitset (array of 1's and 0's) which describes which
documents contain the term.  In our example, the bitset would be: `[1,0,0,0]`

3. *Mask the Index*
+
With the bitset in hand, the documents in the index are "masked". Only
documents containing the term will be evaluated by the query. Since our example
has no query, all matching documents are returned.

4. *Cache the Bitset*
+
Lastly, the bitset is stored in memory, since we can use this in the future and
skip step 1. and 2.  This adds a lot of performance and makes filters very
fast.

The results are exactly as you would expect: only the first document is returned
as a hit. 

[source,json]
--------------------------------------------------
"hits" : [ 
    {
        "_index" : "my_index",
        "_type" : "my_type",
        "_id" : "1",
        "_score" : 1.0, <1>
        "_source" : { 
          "title" : "Twelfth Night" 
        }
    } 
]
--------------------------------------------------
<1> Notice how the score of the document is one.  Filters don't perform any 
scoring, so all documents that match a filter automatically get a score of one.
