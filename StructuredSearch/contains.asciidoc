
==== Contains, but does not equal

It is important to understand that `term` and `terms` are "contains" operations, 
not "equals".  What does that mean?

If you have a term filter for `{ "term" : { "tags" : "search" } }`, it will match 
_both_ of the following documents:

[source,js]
--------------------------------------------------
{ "tags" : ["search"] }
{ "tags" : ["search", "open source"] } <1>
--------------------------------------------------
<1> This document is returned, even though it has terms other than `"search"`

Recall how the `term` filter works: it checks the inverted index for all
documents which contain a term, then constructs a bitset.  This means that only
one of the values within a field has to match for a `1` bit to be set.
This makes `term` (and `terms` too) a "must contain" operation, not a "must equal
exactly" operation.

==== Equals exactly
If you do want that behavior -- entire field equality -- the best way to 
accomplish it involves indexing a secondary field.  In this field, you index the
number of values that your field contains.  Using our two previous documents,
we now include a field that maintains the number of tags:

[source,js]
--------------------------------------------------
{ "tags" : ["search"], "tag_count" : 1 }
{ "tags" : ["search", "open source"], "tag_count" : 2 }
--------------------------------------------------

Once you have the count information indexed, you can construct a `bool` filter 
that enforces the appropriate number of terms:

[source,js]
--------------------------------------------------
GET /my_index/my_type/_search
{
    "filtered" : {
        "filter" : {
             "bool" : {
                "must" : [
                    { "term" : { "tags" : "search" } }, <1>
                    { "term" : { "tag_count" : 1 } } <2>
                ]
            }
        }
    }
}
--------------------------------------------------
<1> Find all documents that have the term `"search"`
<2> But make sure the document only has one tag 

This query will now match only the document that has a single tag which is 
`search`, rather than any document which contains `search`.  This is a very
useful pattern that you may find yourself using often. 

.Why can't Elasticsearch do this automatically?
****
Due to the nature of an inverted index, operations like "only this term" are 
relatively expensive.  

An inverted index looks up the term and finds a list of all documents that 
contain the term.

Entire field equality, however, inverts the requirement.  You need to look up a
document and determine what words are in each field.  This is very expensive to
do in an inverted index.  An inverted index is not optimized for that type of
data access.  It is far more efficient to just index the number of
terms so that you can check manually.
****