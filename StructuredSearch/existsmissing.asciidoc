

Think back to our last example, where documents have a field named `tags`.  This is
a multi-valued field.  A document may have one tag, many tags, or potentially
no tags at all. If a field is not specified at all, how is it stored in an 
inverted index?

That's a trick question, because the answer is "it isn't stored at all". Let's
look at that inverted index from last section:

[width="50%",frame="topbot"]
|==========================
| Token | DocIDs
|`search`| `1`,`2`
|`open_source` | `2`
|==========================

How would you store a field that doesn't exist in that data structure?  You 
can't!  An inverted index is simply a list of tokens and the documents that
contain them.  If a field doesn't exist...it doesn't hold any tokens, which
means it won't be represented in an inverted index data structure.

Ultimately, this means that a `null`, `[]` (an empty array), and `[null]`
are all equivalent...they simply don't exist in the inverted index!

Obviously the world is not simple, and data is often missing fields, contains 
explicit nulls or empty arrays. To deal with these situations, Elasticsearch has 
a few tools to work with null or missing values.

==== Exists Filter

The first tool in your arsenal is the `exists` filter.  This filter will return 
documents that have any value in the specified field. Let's use the tagging example.
First, we need to create an index and make sure the `tags` field is `not_analyzed`
to avoid analysis problems.  Then we can insert some data:

[source,js]
--------------------------------------------------
PUT /my_index <1>
{
    "mappings" : {
        "posts" : {
            "properties" : {
                "tags" : {
                    "type" : "string",
                    "index" : "not_analyzed"
                }
            }
        }
    }
}

POST /my_index/posts/_bulk
{ "index": { "_id": "1"              }}
{ "tags" : ["search"]                }
{ "index": { "_id": "2"              }}
{ "tags" : ["search", "open_source"] }
{ "index": { "_id": "3"              }}
{ "other_field" : "some data"        }
{ "index": { "_id": "4"              }}
{ "tags" : null                      }
{ "index": { "_id": "5"              }}
{ "tags" : ["search", null]          }

--------------------------------------------------
<1> Like we saw earlier in <<_term_filter_with_text>>, we need to explicitly
make these fields `not_analyzed` so that a default analyzer is not applied

This data contains a variety of documents.  The first two documents have normal,
multi-valued data.  Document `3` has no tags at all, while doc `4` explicitly
sets `null` for the `tags` field.  Finally, document `5` has one "real" tag
and one explicit null.  The resulting inverted index for our `tags` field
will look like this:

[width="50%",frame="topbot"]
|==========================
| Token | DocIDs
|`search`| `1`,`2`,`5`
|`open_source` | `2`
|==========================

Our objective is to find all documents where a tag is set.  We don't care what
the tag is, so long as it exists within the document.  In SQL parlance,
we would use an `IS NOT NULL` query:

[source,SQL]
--------------------------------------------------
SELECT tags
FROM posts
WHERE tags IS NOT NULL
--------------------------------------------------

In Elasticsearch, we use the exists filter:

[source,js]
--------------------------------------------------
GET /my_index/posts/_search
{
    "query" : {
        "filtered" : {
            "filter" : {
                "exists" : {"field" : "tags"}
            }
        }
    }
}
--------------------------------------------------

Our query returns three documents:

[source,json]
--------------------------------------------------
"hits" : [
    {
      "_index" : "my_index",
      "_type" : "posts",
      "_id" : "1",
      "_score" : 1.0, "_source" : {"tags" : ["search"] }
    },
    {
      "_index" : "my_index",
      "_type" : "posts",
      "_id" : "5",
      "_score" : 1.0, "_source" : { "tags" : ["search", null] } <1>
    },
    {
      "_index" : "my_index",
      "_type" : "posts",
      "_id" : "2",
      "_score" : 1.0, "_source" : { "tags" : ["search", "open source"] }
    }
]
--------------------------------------------------
<1> Notice how doc `5` is returned, even though we indexed a `null` value. The
field exists because a "normal" tag was indexed, so the `null` had no impact
on the filter.

The results are easy to understand.  Any document that has actual terms in the
`tags` field was returned as a hit.  The only two documents that were excluded
were document `3` and `4`:

[source,js]
--------------------------------------------------
// Document #3
{ "other_field" : "some data" }
--------------------------------------------------
<1> Document `3` didn't specify the `tags` field at all, so it isn't surprising that 
it doesn't match the `exists` filter.

[source,js]
--------------------------------------------------
// Document #4
{ "tags" : null }
--------------------------------------------------
<1> Document `4` did specify the `tags` field, but it passed an explicit `null`.
To Elasticsearch, an explicit `null` is the same a field not existing at all.
Internally, nothing was indexed for that field...it is functionally equivalent
to document `3`.

==== Missing Filter

The Missing filter is essentially the inverse of the Exists filter: it returns
documents where there is _no_ value for a particular field.  Unsurprisingly, 
the SQL is an inverse from before too:

[source,SQL]
--------------------------------------------------
SELECT tags
FROM posts
WHERE tags IS  NULL
--------------------------------------------------

Let's swap the `exists` filter for a `missing` filter from our example above:

[source,js]
--------------------------------------------------
GET /my_index/posts/_search
{
    "query" : {
        "filtered" : {
            "missing" : {"field" : "tags"}
        }
    }
}
--------------------------------------------------

And, as you would expect, we get the inverse search results back (doc `3` and
`4`):

[source,json]
--------------------------------------------------
"hits" : [ 
    {
      "_index" : "my_index",
      "_type" : "posts",
      "_id" : "3",
      "_score" : 1.0, "_source" : { "other_field" : "some data" }
    },
    {
      "_index" : "my_index",
      "_type" : "posts",
      "_id" : "4",
      "_score" : 1.0, "_source" : { "tags" : null }
    }
]
--------------------------------------------------




==== Exists/Missing on Objects

The Exists and Missing filters also work on objects, not just core types.  If
you have the following document:

[source,js]
--------------------------------------------------
{
   "name" : {
      "first" : "foo",
      "last" : "bar"
   }
}
--------------------------------------------------


You can check for the existence of `"name"`.  If the inner object `"name"` exists,
Existing filter matches while Missing does not.

To understand how this actually works, you need to realize that `"name"` is not
really represented as an object internally.  It is merely a namespace, and 
the namespace is "flattened" in the inverted index.

The field `"first"` is actually stored in the inverted index as `"name.first"`,
and `"last"` is stored as `"name.last"`.

When you perform an `exists` or `missing` on the object, you are effectively
asking "Are there any terms with in the `name` namespace?".  In more technical
terms, the following query:

[source,js]
--------------------------------------------------
{
    "exists" : {"field" : "name"}
}
--------------------------------------------------

Is really translated to this internally:

[source,js]
--------------------------------------------------
{
    "exists" : {"field" : "name.*"}
}
--------------------------------------------------



