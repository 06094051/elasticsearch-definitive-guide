=== Sorting results

By default, results are returned sorted by _relevance_ -- with the most
relevant docs first. The _relevance score_ is represented by a number
returned as the `_score`, so the default sort order is `_score` descending.

Sometimes, though, you don't have a meaningful relevance score. For instance,
the following query just returns all tweets whose `user_id` field has
the value `2`:

    curl localhost:9200/_search  -d '
    {
        "query" : {
            "filtered" : {
                "filter" : { "term" : { "user_id" : 2 }}
            }
        }
    }
    '

The missing-but-implied `match_all` query just sets the `_score` to `1`
for all documents, and filters don't have any effect on the score. This
means that all of our results have the meaningless `_score` of `1` -- they
are all equally relevant.

==== Sorting by field values

In this case, we probably want to sort the results by recency, with the most
recent tweets first.  We can do this with the `sort` parameter:

    curl localhost:9200/_search  -d '
    {
        "query" : {
            "filtered" : {
                "filter" : { "term" : { "user_id" : 2 }}
            }
        },
        "sort": { "date": { "order": "desc" }}
    }
    '

You will notice two differences in the results:

    "hits" : {
        "total" :           6,
        "max_score" :       null,
        "hits" : [ {
            "_index" :      "us",
            "_type" :       "tweet",
            "_id" :         "13",
            "_score" :      null,
            "_source" :     { ... },
            "sort" :        [ 1379894400000 ]
        },
        ...
    }

The first is that we have a new element in each result called `sort`, which
contains the value(s) that was used for sorting.  In this case, we sorted
on `date` which internally is indexed as _milliseconds-since-the-epoch_.
The long number `1379894400000` is equivalent to `2013-09-23 00:00:00 UTC`.

The second is that the `_score` and `max_score` are `null`.  Calculating the
`_score` is quite expensive and usually its only purpose is for
sorting -- we're not sorting by relevance, so it doesn't make
sense to keep track of the `_score`.  If you want the `_score` to be
calculated regardless, then you can set the `track_score` parameter to `true`.

==== Multi-level sorting

Perhaps we want to combine the `_score` from a query with the `date`, and
show all matching results sorted first by date, then by relevance:

    curl localhost:9200/_search  -d '
    {
        "query" : {
            "filtered" : {
                "query":   { "match": { "tweet": "full text search" }},
                "filter" : { "term" : { "user_id" : 2 }}
            }
        },
        "sort": [
            { "date":   { "order": "desc" }},
            { "_score": { "order": "desc" }}
        ]
    }
    '

Order is important.  Results are sorted by the first criterion first. Only
results whose first `sort` value is identical will then be sorted by the
second criterion, and so on.

==== Default sort order

As a shortcut, you can specify just the name of the field to sort on.
In this case, it will use the default sort order which is
`desc` for `_score` and `asc` for all other fields.  The `sort`
argument from the above query could be written as:

       "sort": [
            { "date":   { "order": "desc" }},
            "_score"
       ]

==== Sorting on multi-value fields

When sorting on field with more than one value, remember that the values do not
have any intrinsic order -- a multi-value field is just a bag of values.
Which one do you choose to sort on?

For numbers and dates, you can reduce a multi-value field to a single value
using the `min`, `max`, `avg` or `sum` _sort modes_. For instance, you
could sort on the earliest date in the `dates` field using:

    "sort": {
        "dates": {
            "order": "asc",
            "mode":  "min"
        }
    }

However, analyzed string fields are not so easy. If you analyze a string like
`"quick brown fox"`, it results in three terms. We probably want to
sort alphabetically on the first term, then the second term, etc, but
Elasticsearch doesn't have this information at its disposal.

Later on in <<mapping>>, we will show you how to index a single field both
as an `analyzed` full text field (for searching) and as a `not_analyzed`
string field for sorting.

==== Sorting and query string search

Query string search also supports custom sorting, using the `sort` parameter
in the query string:

    curl 'localhost:9200/_search?sort=date:desc&q=*'

Multiple sort parameters can be specified in order:

    curl 'localhost:9200/_search?sort=date:desc&sort=_score&q=search'

