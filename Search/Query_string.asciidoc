=== Search _Lite_

There are two forms of the `search` API: a ``lite'' _query string_ version
that expects all its parameters to be passed in the query string, and the full
_request body_ version that expects a JSON request body and uses a search
language called the query DSL.

The query string search is simple to use and is particularly useful for
running _ad hoc_ queries from the command line.
For instance this query finds all tweets containing the word `"elasticsearch"`
in the `tweet` field:

    curl -XGET 'localhost:9200/_all/tweet/_search?q=tweet:elasticsearch'

The following query looks for `"john"` in the `name` field and `"mary"` in the
`tweet` field. The actual query is just `"+name:john +tweet:mary"` but
the _percent encoding_ of the query string parameters makes it appear more
cryptic than it really is:

    curl -XGET 'localhost:9200/_search?q=%2Bname%3Ajohn+%2Btweet%3Amary'

The `"+"` prefix indicates conditions which _must_ be satisfied for our query to
match. Similarly a `"-"` prefix would indicate conditions that _must not_
match.  All of the conditions are optional -- the more that match,
the more relevant the document.

==== The `_all` field

This simple search returns all documents which contain the word `"mary"`:

    curl -XGET 'localhost:9200/_search?q=mary'

In the previous examples, we searched for words in the `tweet` or
`name` fields. However, the results from this query mention `"mary"` in
three different fields:

* a user whose name is "Mary"
* six tweets by "Mary"
* one tweet directed at "@mary"

How has Elasticsearch managed to find results in three different fields?

The answer is that, when you index a document, Elasticsearch takes the
string values of all of its fields and concatenates them into one big
string which it indexes as the special `_all` field. For example, when we
index the following document:

    {
        "tweet":    "However did I manage before Elasticsearch?",
        "date":     "2013-09-14",
        "name":     "Mary Jones",
        "user_id":  1
    }

it's as if we had added an extra field called `_all` with the value:

    "However did I manage before Elasticsearch? 2013-09-14 Mary Jones 1"

The query string search uses the `_all` field unless another
field name has been specified.

==== More complicated queries

The next query searches for tweets:

* where the `name` field contains `"mary"` or `"john"`
* where the `date` is greater than `2013-09-10`
* and which contain either of the words `"facets"` or `"geo"` in the `_all`
  field

    +name:(mary john) +date:>2013-09-10 +(facets geo)

which, as a properly escaped query string looks like the slightly less
readable:

    q=%2Bname%3A(mary+john)+%2Bdate%3A%3E2013-09-10+%2B(facets+geo)

As you can see from the above examples, this _lite_ query string search is
surprisingly powerful. Its query syntax, which is explained in detail in
<<query-string-syntax>>,  allows us to express quite complex queries
succinctly, which makes it great for running _ad hoc_ queries from the
command line during development.

However, you can also see that its terseness can soon make it cryptic and
difficult to debug. And it's fragile -- a slight syntax error in the query
string, such as a misplaced `-`, `:` or `"` and it will return an error
instead of results.

Lastly, the query string search allows any user to run potentially
slow heavy queries on any field in your index, possibly exposing private
information or even bringing your cluster to its knees!

For these reasons, we don't recommend exposing the query string
search directly to your users, unless they are power users who can
be trusted with your data and with your cluster. (Not your boss.  Definitely
not your boss.)

Instead, in production we usually rely on the full-featured
_request body_ search API, which does all of the above, plus a lot more.

Before we get there though, we first need to take a look at how our data is
indexed in Elasticsearch.

