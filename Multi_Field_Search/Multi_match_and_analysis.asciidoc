=== Problem 1: Exact value fields

Because the `multi_match` query generates a separate `match` clause for each
field, each `match` clause will analyze the query string with the appropriate
analyzer for that field.

To demonstrate this, let's setup this mapping for our product documents:

[source,js]
--------------------------------------------------
DELETE /my_index

PUT /my_index
{
    "mappings": {
        "product": {
            "properties": {
                "name": { <1>
                    "type":             "string"
                },
                "desc": { <2>
                    "type":             "string",
                    "analyzer":         "english"
                },
                "store": {
                    "type":             "object",
                    "properties": {
                        "postcode": { <3>
                            "type":     "string",
                            "index":    "not_analyzed"
                        }
                    }
                }
            }
        }
    }
}
--------------------------------------------------
<1> The `name` field uses the default `standard` analyzer.
<2> The `desc` field uses the `english` analyzer.
<3> The `store.postcode` field is an exact value `not_analyzed` field.

We can use the `validate-query` API to see how the high-level `multi_match`
query gets executed internally. This query for ``awesome widgets'' in the
`name` and `desc` fields :

[source,js]
--------------------------------------------------
GET /my_index/_validate/query?explain
{
    "multi_match": {
        "query": "awesome widgets",
        "fields": [ "name", "desc"]
    }
}
--------------------------------------------------

results in the following explanation:

    ((desc:awesom desc:widget) | (name:awesome name:widgets))

You can see that the query string ``awesome widgets'' has been converted into
the terms `awesome` and `widgets` for the `name` field, which uses the
`standard` analyzer, and into their stemmed forms for the `desc` field, which
uses the `english` analyzer.

This per-field analysis works well until one of the fields is an exact value
`not_analyzed` field.

[[multi-match-exact-values]]
==== `multi-match` and `not_analyzed` fields.

What would happen if we tried to include a postal code in the query string,
such as in this example:

[source,js]
--------------------------------------------------
GET /my_index/_validate/query?explain
{
    "multi_match": {
        "query": "widgets WC1",
        "fields": [ "name", "postcode"]
    }
}
--------------------------------------------------

The `store.postcode` field is a `not_analyzed` string, so the whole query
string is treated as a single term:

    (postcode:widgets WC1 | (name:widgets name:wc1))

Of course, the exact term `widgets WC1` does not exist in the `postcode`
field, and so this clause will not match.

Either we need to make the `postcode` field `analyzed` or apply one of the
other solutions that we discuss later in this chapter.
