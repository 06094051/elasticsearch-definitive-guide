=== Problem 3: Field-centric matching

The `multi_match` query is _field-centric_. In other words, it tries to match
the whole query string against each field in turn.  If we pass our earlier
query through the `validate-query` API:

[source,js]
--------------------------------------------------
POST /my_index/_validate/query?explain
{
    "multi_match": {
        "query":       "red widget london",
        "fields":      [ "name", "color", "city" ],
        "use_dis_max": false
    }
}
--------------------------------------------------

we see that the explanation reflects this field-centric nature:

      (color:red color:widget color:london)
    | (name:red  name:widget  name:london)
    | (city:red  city:widget  city:london)

If we had a document which contained the word `london` in the `name`, `color`
and `city` fields, it would be a very good match for this query, even though
it mentions neither widgets nor red!

Instead we want a _word-centric_ query which looks for each word in at least
one field, such as this:

      (color:red    name:red    city:red)
    | (color:widget name:widget city:widget)
    | (color:london name:london city:london)

This becomes even more important when we try to set `operator` to `and` --
each word *must* appear in at least one field:

     +(color:red    name:red    city:red)
     +(color:widget name:widget city:widget)
     +(color:london name:london city:london)

In fact, this field-centricity is the common thread that runs through all
three of the problems we have looked at.  We need to find a way to make our
query word-centric instead.


