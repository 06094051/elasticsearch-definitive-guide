[[custom-all-fields]]
=== Custom `_all` fields

By default, each field is indexed into its own inverted index named after the
field name.  So for a document like the following:

[source,js]
--------------------------------------------------
{
    "first_name": "John",
    "last_name":  "Smith",
    "addr": {
        "city":     "Barcelona",
        "country":  "Spain"
    }
}
--------------------------------------------------

the `first_name` and `last_name` fields are indexed into the `first_name` and
`last_name` inverted indices respectively, and the `city` and `country` fields
would be indexed into `addr.city` and `addr.country` respectively. You can
still search on `city` and `country` rather than using the full name because
Elasticsearch keeps a record of the short and long versions of each inverted
index name.

However, we can control which inverted index each field uses, with the
`index_name` parameter.  If we give `first_name` and `last_name` the same
index name then the values from both fields will be indexed into the same
inverted index, meaning  that we can search them as if they were one commmon
field, like a custom `_all` field.

In order to setup this common field, we need to set the `index_name` in the
mapping:

[source,js]
--------------------------------------------------
PUT /my_index/
{
    "mappings": {
        "user": {
            "properties": {
                "first_name": {
                    "type":       "string",
                    "index_name": "full_name" <1>
                },
                "last_name": {
                    "type":       "string",
                    "index_name": "full_name" <1>
                }
            }
        }
    }
}
--------------------------------------------------
<1> The `first_name` and `last_name` fields will both be indexed into (and
    searchable via) the `full_name` inverted index.

Now we can index our document:

[source,js]
--------------------------------------------------
PUT /my_index/user/1
{
    "first_name": "John",
    "last_name":  "Smith"
}
--------------------------------------------------

And a simple `match` query against the `full_name` field returns our document,
even with `operator` set to `"and"`:

[source,js]
--------------------------------------------------
GET /my_index/user/_search
{
    "query": {
        "match": {
            "full_name": {
                "query":    "John Smith",
                "operator": "and"
            }
        }
    }
}
--------------------------------------------------

A downside to this solution is that the `first_name` and `last_name` fields
can no longer be queried independently -- the values from both fields are only
indexed into the `full_name` inverted index.   If you try to search on the
`first_name` or `last_name` field, it will actually query just the `full_name`
inverted index.

It is possible to index fields both into a common field and independently, but
it requires a bit more setup.  We need to index a single field in two
different ways: once as itself, and once as part of a common field.  The way
to do this is with multi-fields, which we introduced in <<signal-fields>>.

[source,js]
--------------------------------------------------
DELETE /my_index

PUT /my_index
{
    "mappings": {
        "person": {
            "first_name": {
                "type":             "multi_field",
                "path":             "just_name", <1>
                "fields": {
                    "first_name": { "type": "string" },
                    "full_name":  { "type": "string" }  <2>
                }
            },
            "last_name": {
                "type":             "multi_field",
                "path":             "just_name", <1>
                "fields": {
                    "last_name":  { "type": "string" },
                    "full_name":  { "type": "string" }  <2>
                }
            }
        }
    }
}
--------------------------------------------------
<1> Note the new `path` parameter.
<2> These two sub-fields will be indexed into the common `full_name` field.

The above mapping only works because of the `path` parameter, which controls
how the name of each inverted index is formed.  It can take two values:

[horizontal]
`full`::

    (default) Use the full path for each field, so the `full_name` sub-field
    would become the inverted index `first_name.full_name`.

`just_name`::

    Ignore the path and use just the field name itself, so `full_name` becomes
    the inverted index `full_name`.

If we had left `path` with its default `full` setting then we would have four
different fields:

* `first_name`
* `first_name.full_name`
* `last_name`
* `last_name.full_name`

By setting it to `just_name`, the two `*.full_name` fields lose their path
prefix and become the single field `full_name`.

We can reindex our test document:

[source,js]
--------------------------------------------------
PUT /my_index/user/1
{
    "first_name": "John",
    "last_name":  "Smith"
}
--------------------------------------------------

And demonstrate that each field has been indexed both independently and into
the common `full_name` field:

[source,js]
--------------------------------------------------
GET /my_index/_search?q=first_name:John     # ok
GET /my_index/_search?q=first_name:Smith    # not ok

GET /my_index/_search?q=last_name:John      # not ok
GET /my_index/_search?q=last_name:Smith     # ok

GET /my_index/_search?q=full_name:John      # ok
GET /my_index/_search?q=full_name:Smith     # ok
--------------------------------------------------

Indexing several cooperative fields into a single common field simplifies the
complexities of multi-field search. We don't need to worry about different
fields having different analysis settings or different IDFs, and we can
control the ``long tail'' of less relevant results with the
`minimum_should_match` parameter.

It requires a bit of work up front, before indexing your data, but your
queries will be faster and the results more accurate.

