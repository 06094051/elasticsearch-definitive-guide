=== Cooperative fields and IDF

In <<relevance-intro>>, we explained that the default similarity algorithm --
used to calculate the relevance score for each term -- is TF/IDF:

Term Frequency::

    The more often a term appears in a field in a single document, the more
    relevant the document.

Inverse Document Frequency::

    The more often a term appears in a field in all documents in the index,
    the less relevant is that term.

When searching against multiple collaborative fields, TF/IDF can introduce
some surprising results.

Consider the situation where we are searching for people using the
`first_name` and `last_name` fields. In our database we have, amongst
thousands of other people, one individual named Peter Smith, and another named
Smith Williams.

Now we run this query looking for ``Peter Smith'':

[source,js]
--------------------------------------------------
GET /my_index/_search
{
    "query": {
        "query_string": {
            "query":    "Peter Smith",
            "fields": [ "first_name", "last_name" ]
        }
    }
}
--------------------------------------------------

We may well find that Smith Williams appears at the top of the results list,
above the better match Peter Smith.  Why does this happen?

The `first_name` and `last_name` fields each have their own IDF for each term.
Peter is a common first name, and Smith is a common last name, which means
that `first_name:peter` and `last_name:smith` will both have a low IDF and so
be of low importance.  However, Smith as a *first name* is very uncommon and
will be considered very important, perhaps important enough to overwhelm the
score on the Peter Smith document.

If, however, we were to index both first name and last name into a single
`full_name` field, then it wouldn't matter whether Smith is a first name or
last name -- it will have have the same low IDF in either position, which
would improve the accuracy of our results.

In <<all-field-intro>> and <<all-field>> we introduced the special `_all`
field, which concatenates the values from all other fields into one big string
and indexes it as an `analyzed` string field.

This sounds like what we want: by indexing both `first_name` and `last_name`
into one field, instead of dealing with the complexities of multi-field
search, we can query just a single field, and we benefit from the correct
pooled IDFs.

By default, though, the `_all` field doesn't contain just the first and last
names -- it contains all of the other field values as well.  We could change
that by mapping the other fields as follows:

[source,js]
--------------------------------------------------
    "user_id": {
        "type":           "string",
        "index":          "not_analyzed",
        "include_in_all": false <1>
    }
--------------------------------------------------
<1> This setting means that the `user_id` will not be added to the `_all`
    field.

However, it is quite likely that we want several common fields, perhaps one
for first name and last name, and another for address, city and country.
We need some way of defining custom `_all` fields.


