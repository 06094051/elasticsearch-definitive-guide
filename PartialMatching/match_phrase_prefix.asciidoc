
Often you'll find the Prefix query to be stifling - you need to search for a phrase but want partial matching on the last term.  A classic example of this is "as you type" autocompletion (ala Google Instant).

The match query provides an alternate syntax that bundles phrase and prefix matching together.  It is a fully analyzed query, so it "does the right thing" with your full-text search.  Let's take a look at an example and see what Elasticsearch is doing internally:

    {
        "match_phrase_prefix" : {
            "message" : {
                "query" : "example of a te",
                "max_expansions" : 10,
                "analyzer" : "standard"
            }
        }
    }

This query is looking for the phrase "example of a te", but allowing the last term to act as independently as a prefix query.  And because the query is analyzed, there are three distinct actions that are ocurring:

 1. Analysis of the phrase
 2. Prefix expansion
 3. Position matching

==== Analysis phase

First, the prase is fully analyzed using either the default analyzer for the field or an analyzer that you provide.  In the above example, we are using the Standard analyzer.

Standard analyzer will split tokens by whitespace, and also remove stop words.  The final tokens are ["example", "te"].

==== Prefix Expansion

In the next phase, the last token ("te") is expanded to a list of matching prefix tokens, just like the Prefix query.  All tokens that match start with "te*" and compiled into a list.

Because we specified `max_expansions`, only 10 prefix expansions are added to the list of terms to query.  Elasticsearch adds prefixes in alphabetical (lexagraphical) order, and simply stops adding them when the max is reached.

Specifying a sane max_expansions options is important for performance.  If you allow too many expansions, it is possible to generate a very large (and slow) query.

==== Position Matching

At this point, we have a list of tokens that we can search the index with.  In position 1 we have the token "example".  At position 2 we have any matching prefix tokens ("test", "team", "tea", etc).

The query will now find all documents that have these tokens within the specified slop distance.  Default slop is zero, so our query is looking for exact phrases: "example test", "example team", etc.

==== Watch out for stemming!

Analysis happens before the prefix expansion, which means stemmed words are expanded for prefix matching.  If you use an analyzer that stems (like Snowball Analyzer), take a moment to verify that you have it setup correctly.  Consider the phrase "the party".

After stemming and stop word removal, you'll be left with a single, stemmed token:  "parti".  This token is then expanded for prefix matches, in the form of "parti*".

If you are searching with the same analyzer that you indexed with - everything is fine.  Your indexed data is also stemmed, so matches will make sense.

But let's say you indexed your data with an analyzer that *didn't* stem.  Now your query for "the party" will match phrases such as "the partition", because "parti*" expands to match "partition" (which was not stemmed at index time).

This can lead to considerable confusion in autocomplete situations, since "partition" is not a natural expansion of "party".





