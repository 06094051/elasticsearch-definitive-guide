[[distributed-search]]
== Distributed Search Execution

Before moving on, we are going to take a detour and talk about how search is
executed in a distributed environment.((("distributed search execution")))  It is a bit more complicated than the
basic _create-read-update-delete_ (CRUD) requests((("CRUD (create-read-update-delete) operations"))) that we discussed in
<<distributed-docs>>.

.Content Warning
****

The information presented in this chapter is for your interest. You are not required to
understand and remember all the detail in order to use Elasticsearch.

Read this chapter to gain a taste for how things work, and to know where the
information is in case you need to refer to it in the future, but don't be
overwhelmed by the detail.

****

A CRUD operation deals with a single document that has a unique combination of
`_index`, `_type`, and <<routing-value,`routing` values>> (which defaults to the
document's `_id`). This means that we know exactly which shard in the cluster
holds that document.

Search requires a more complicated execution model because we don't know which
documents will match the query: they could be on any shard in the cluster. A
search request has to consult a copy of every shard in the index or indices
we're interested in to see if they have any matching documents.

But finding all matching documents is only half the story. Results from
multiple shards must be combined into a single sorted list before the `search`
API can return a ``page'' of results. For this reason, search is executed in a
two-phase process called _query then fetch_.
[[分布式检索]]
== 分布式检索执行

在开始之前，我们先来讨论有关在分布式环境中检索是如何进行的。((("distributed search execution")))比我们之前在<<distributed-docs>>中讨论过的基础的_create-read-update-delete_ (CRUD)请求的((("CRUD (create-read-update-delete) operations")))较为简单。

.内容提示
****

你有兴趣的话可以读一读这章，并不需要为了使用Elasticsearch而理解和记住所有的细节。

这章的阅读目的只为在脑海中形成服务运行的梗概以及了解信息的存放位置以便不时之需，但是不要被细节搞的云里雾里。

****

CRUD的操作处理一个单个的文档，此文档中有一个`_index`, `_type`和<<routing-value,`routing` values>>之间的特殊连接，其中<<routing-value,`routing` values>>的缺省值为`_id`。这意味着我们知道在集群中哪个分片存有此文档。

检索需要一个更为精细的模型因为我们不知道哪条文档会被命中：这些文档可能分布在集群的任何分片上。一条检索的请求需要参考我们感兴趣的所有索引中的每个分片复本，这样来确认索引中是否有任何匹配的文档。

定位所有的匹配文档仅仅是开始，不同分片的结果在`search`的API返回``page''结果前必须融合到一个单个的已分类列表中。正因为如此，检索执行通常两步走，先是_query，然后是fetch_。
